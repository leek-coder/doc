
如何保证数据并发访问的一致性，有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素，锁对数据库而言显得尤其重要，也更加复杂。


锁的分类：

从性能分为乐观锁(用版本对比来实现)和悲观锁
从对数据库操作的类型分：读锁和写锁(都属于悲观锁)  写锁(排他锁)
从对数据库做的粒度分：分为表锁和行锁

表锁偏向于MyISAM存储引擎，开销小，加锁块，无死锁。

加读锁

lock table xxx read;

当前session和其他session都可以读该表
当前session中插入或者更新



unlock tables;  解锁


加写锁
lock table xxx write;
当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞。


=============表锁=======================
案例结论  
MyIASM在执行查询语句(select)前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。
1：对MyISAM表的读操作(加读锁)，不会阻塞其他进程对同一表的读请求，但是会阻塞对同一表的写请求，只有当读锁释放后，才能执行其他进程的写操作。
2:对MyISAM表的写操作(加写锁)，会阻塞其他线程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。

==================================行锁(偏写)=======================


行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁粒度小，发生锁冲突的概率最低
InnoDB与MyISAM的最大不同有亮点，一是支持事务，二是采用了行级锁。


不可重复读：
概括：事务A读取到了事务B已经提交的修改数据，不符合隔离性。

幻读：
概括：事务A读取到了事务B提交的新增数据，不符合隔离性。




























